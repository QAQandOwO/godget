package fieldenum

import (
	"errors"
	"math"
	"math/cmplx"
	"testing"
)

type parseTest struct {
	expr   string
	funcs  map[string]ExprFunc
	values map[string]any
	want   any
	retErr bool
}

func gotEqlWant(got, want any) bool {
	return (want == want && got == want) || (want != want && got != got)
}

func testParse(t *testing.T, i int, test parseTest) {
	var got any
	fset, tree, err := parse(test.expr)
	if err == nil {
		if test.funcs == nil {
			test.funcs = make(map[string]ExprFunc)
		}
		if test.values == nil {
			test.values = make(map[string]any)
		}

		conf := &config{
			funcs:  test.funcs,
			values: test.values,
		}
		got, err = eval(conf, test.expr, fset, tree)
	}

	switch {
	case test.retErr:
		if err == nil {
			t.Errorf("[%d]ERROR: got %v, want error", i, got)
		} else {
			//t.Logf("[%d]INFO: %v", i, err)
		}
	case !test.retErr && err != nil:
		t.Errorf("[%d]ERROR: got %v, want no error", i, err)
	case !gotEqlWant(got, test.want):
		t.Errorf("[%d]ERROR: got %v, want %v", i, got, test.want)
	}
}

func TestParse(t *testing.T) {
	t.Run("constants", func(t *testing.T) {
		tests := []parseTest{
			0:  {expr: "0", want: int64(0)},
			1:  {expr: "0.0", want: 0.0},
			2:  {expr: "0i", want: 0i},
			3:  {expr: "i", want: 1i},
			4:  {expr: "e", want: math.E},
			5:  {expr: "pi", want: math.Pi},
			6:  {expr: "Pi", want: math.Pi},
			7:  {expr: "phi", want: math.Phi},
			8:  {expr: "Phi", want: math.Phi},
			9:  {expr: "nan", want: math.NaN()},
			10: {expr: "NaN", want: math.NaN()},
			11: {expr: "inf", want: math.Inf(1)},
			12: {expr: "Inf", want: math.Inf(1)},
			13: {expr: "", retErr: true},
			14: {expr: "a", retErr: true},
			15: {expr: "'a'", retErr: true},
			16: {expr: "iota", want: nil},
			17: {expr: "iota", values: map[string]any{"iota": int64(1)}, want: int64(1)},
			18: {expr: "9223372036854775808", want: 9223372036854775808.0},
			19: {expr: "-9223372036854775809", want: -9223372036854775809.0},
		}

		for i, test := range tests {
			testParse(t, i, test)
		}
	})

	t.Run("operators", func(t *testing.T) {
		tests := []parseTest{
			0:  {expr: "(0)", want: int64(0)},
			1:  {expr: "+(1)", want: int64(1)},
			2:  {expr: "-(1)", want: int64(-1)},
			3:  {expr: "^1", want: ^int64(1)},
			4:  {expr: "0+1", want: int64(1)},
			5:  {expr: "0-1", want: int64(-1)},
			6:  {expr: "0*1", want: int64(0)},
			7:  {expr: "0/1", want: int64(0)},
			8:  {expr: "1/2", want: int64(0)},
			9:  {expr: "0%1", want: int64(0)},
			10: {expr: "1&2", want: int64(1) & int64(2)},
			11: {expr: "1|2", want: int64(1) | int64(2)},
			12: {expr: "1^2", want: int64(1) ^ int64(2)},
			13: {expr: "1<<2", want: int64(1) << int64(2)},
			14: {expr: "1>>2", want: int64(1) >> int64(2)},
			15: {expr: "1&^2", want: int64(1) &^ int64(2)},
			16: {expr: "+1.0", want: 1.0},
			17: {expr: "-(1.0)", want: -1.0},
			18: {expr: "0.0+1.0", want: 1.0},
			19: {expr: "0.0-1.0", want: -1.0},
			20: {expr: "0.0*1.0", want: 0.0},
			21: {expr: "0.0/1.0", want: 0.0},
			22: {expr: "0.0%1.0", want: 0.0},
			23: {expr: "+1i", want: 1i},
			24: {expr: "-(1i)", want: -1i},
			25: {expr: "0i+1i", want: 1i},
			26: {expr: "0i-1i", want: -1i},
			27: {expr: "0i*1i", want: 0i},
			28: {expr: "0i/1i", want: 0i},
			29: {expr: "0.0+1", want: 1.0},
			30: {expr: "0.0-1", want: -1.0},
			31: {expr: "0.0*1", want: 0.0},
			32: {expr: "0.0/1", want: 0.0},
			33: {expr: "0.0%1", want: 0.0},
			34: {expr: "0i+1", want: 1 + 0i},
			35: {expr: "0i-1", want: -1 + 0i},
			36: {expr: "0i*1", want: 0i},
			37: {expr: "0i/1", want: 0i},
			38: {expr: "1<<64", want: int64(0)},
			39: {expr: "1>>64", want: int64(0)},
			40: {expr: "-(-9223372036854775808)", want: 9223372036854775808.0},
			41: {expr: "9223372036854775807+1", want: 9223372036854775808.0},
			42: {expr: "-9223372036854775808-1", want: -9223372036854775809.0},
			43: {expr: "-9223372036854775808*(-1)", want: 9223372036854775808.0},
			44: {expr: "-9223372036854775808/(-1)", want: 9223372036854775808.0},
			45: {expr: "1/0", want: math.Inf(1)},
			46: {expr: "-1/0", want: math.Inf(-1)},
			47: {expr: "0/0", want: math.NaN()},
			48: {expr: "1%0", want: math.NaN()},
			49: {expr: "1.0%0.0", want: math.NaN()},
			50: {expr: "inf%1.0", want: math.NaN()},
			51: {expr: "nan%1.0", want: math.NaN()},
			52: {expr: "1<<(-1)", retErr: true},
			53: {expr: "1>>(-1)", retErr: true},
			54: {expr: "^1.0", retErr: true},
			55: {expr: "1.0&1.0", retErr: true},
			56: {expr: "1.0|1.0", retErr: true},
			57: {expr: "1.0^1.0", retErr: true},
			58: {expr: "1.0<<1.0", retErr: true},
			59: {expr: "1.0>>1.0", retErr: true},
			60: {expr: "1.0&^1.0", retErr: true},
			61: {expr: "^1i", retErr: true},
			62: {expr: "1i%1", retErr: true},
			63: {expr: "1i&1i", retErr: true},
			64: {expr: "1i|1i", retErr: true},
			65: {expr: "1i^1i", retErr: true},
			66: {expr: "1i<<1i", retErr: true},
			67: {expr: "1i>>1i", retErr: true},
			68: {expr: "1i&^1i", retErr: true},
			69: {expr: "+", retErr: true},
			70: {expr: "-", retErr: true},
			71: {expr: "*", retErr: true},
			72: {expr: "/", retErr: true},
			73: {expr: "%", retErr: true},
			74: {expr: "&", retErr: true},
			75: {expr: "|", retErr: true},
			76: {expr: "^", retErr: true},
			77: {expr: "<<", retErr: true},
			78: {expr: ">>", retErr: true},
			79: {expr: "&^", retErr: true},
			80: {expr: "1+", retErr: true},
			81: {expr: "1-", retErr: true},
			82: {expr: "1*", retErr: true},
			83: {expr: "*1", retErr: true},
			84: {expr: "1/", retErr: true},
			85: {expr: "/1", retErr: true},
			86: {expr: "1%", retErr: true},
			87: {expr: "%1", retErr: true},
			88: {expr: "1&", retErr: true},
			89: {expr: "&1", retErr: true},
			90: {expr: "1|", retErr: true},
			91: {expr: "|1", retErr: true},
			92: {expr: "1^", retErr: true},
			93: {expr: "1<<", retErr: true},
			94: {expr: "<<1", retErr: true},
			95: {expr: "1>>", retErr: true},
			96: {expr: ">>1", retErr: true},
			97: {expr: "1&^", retErr: true},
			98: {expr: "&^1", retErr: true},
		}

		for i, test := range tests {
			testParse(t, i, test)
		}
	})

	t.Run("functions", func(t *testing.T) {
		fn := func(values []any) (any, error) {
			if len(values) == 0 {
				return nil, errors.New("0 argument")
			}
			return 0.0, nil
		}

		tests := []parseTest{
			0:   {expr: "int(1)", want: int64(1)},
			1:   {expr: "int(1.0)", want: int64(1)},
			2:   {expr: "int(1i)", retErr: true},
			3:   {expr: "int(inf)", want: int64(math.MaxInt64)},
			4:   {expr: "int(-inf)", want: int64(math.MinInt64)},
			5:   {expr: "int(nan)", want: int64(math.MinInt64)},
			6:   {expr: "int", retErr: true},
			7:   {expr: "int()", retErr: true},
			8:   {expr: "int(1,2)", retErr: true},
			9:   {expr: "float(1)", want: 1.0},
			10:  {expr: "float(1.0)", want: 1.0},
			11:  {expr: "float(1i)", retErr: true},
			12:  {expr: "float(inf)", want: math.Inf(1)},
			13:  {expr: "float(-inf)", want: math.Inf(-1)},
			14:  {expr: "float(nan)", want: math.NaN()},
			15:  {expr: "float", retErr: true},
			16:  {expr: "float()", retErr: true},
			17:  {expr: "float(1,2)", retErr: true},
			18:  {expr: "complex(1)", want: 1 + 0i},
			19:  {expr: "complex(1.0)", want: 1 + 0i},
			20:  {expr: "complex(1+0i)", want: 1 + 0i},
			21:  {expr: "complex(inf)", want: complex(math.Inf(1), 0)},
			22:  {expr: "complex(-inf)", want: complex(math.Inf(-1), 0)},
			23:  {expr: "complex(nan)", want: complex(math.NaN(), 0)},
			24:  {expr: "complex(1,0)", want: 1 + 0i},
			25:  {expr: "complex(1.0,0.0)", want: 1 + 0i},
			26:  {expr: "complex(1i,0i)", retErr: true},
			27:  {expr: "complex(1,inf)", want: 1 + complex(0, math.Inf(1))},
			28:  {expr: "complex(1,-inf)", want: 1 + complex(0, math.Inf(-1))},
			29:  {expr: "complex(1,nan)", want: 1 + complex(0, math.NaN())},
			30:  {expr: "complex", retErr: true},
			31:  {expr: "complex()", retErr: true},
			32:  {expr: "complex(1,2,3)", retErr: true},
			33:  {expr: "real(1)", want: int64(1)},
			34:  {expr: "real(1.0)", want: 1.0},
			35:  {expr: "real(1+0i)", want: 1.0},
			36:  {expr: "real(inf)", want: math.Inf(1)},
			37:  {expr: "real(-inf)", want: math.Inf(-1)},
			38:  {expr: "real(nan)", want: math.NaN()},
			39:  {expr: "real", retErr: true},
			40:  {expr: "real()", retErr: true},
			41:  {expr: "real(1,2)", retErr: true},
			42:  {expr: "imag(1)", want: int64(0)},
			43:  {expr: "imag(1.0)", want: 0.0},
			44:  {expr: "imag(1+0i)", want: 0.0},
			45:  {expr: "imag(inf)", want: 0.0},
			46:  {expr: "imag(-inf)", want: 0.0},
			47:  {expr: "imag(nan)", want: 0.0},
			48:  {expr: "imag", retErr: true},
			49:  {expr: "imag()", retErr: true},
			50:  {expr: "imag(1,2)", retErr: true},
			51:  {expr: "max(1)", want: int64(1)},
			52:  {expr: "max(1.0)", want: 1.0},
			53:  {expr: "max(1,2)", want: int64(2)},
			54:  {expr: "max(1.0,2.0)", want: 2.0},
			55:  {expr: "max(1,2.0)", want: 2.0},
			56:  {expr: "max(1.0,2)", want: int64(2)},
			57:  {expr: "max(i)", retErr: true},
			58:  {expr: "max(nan)", want: math.NaN()},
			59:  {expr: "max(inf,1)", want: math.Inf(1)},
			60:  {expr: "max(-inf,1)", want: int64(1)},
			61:  {expr: "max(nan,1)", want: int64(1)},
			62:  {expr: "max", retErr: true},
			63:  {expr: "max()", retErr: true},
			64:  {expr: "min(1)", want: int64(1)},
			65:  {expr: "min(1.0)", want: 1.0},
			66:  {expr: "min(1, 2)", want: int64(1)},
			67:  {expr: "min(1.0, 2.0)", want: 1.0},
			68:  {expr: "min(1, 2.0)", want: int64(1)},
			69:  {expr: "min(1.0, 2)", want: 1.0},
			70:  {expr: "min(i)", retErr: true},
			71:  {expr: "min(nan)", want: math.NaN()},
			72:  {expr: "min(inf,1)", want: int64(1)},
			73:  {expr: "min(-inf,1)", want: math.Inf(-1)},
			74:  {expr: "min(nan,1)", want: int64(1)},
			75:  {expr: "min", retErr: true},
			76:  {expr: "min()", retErr: true},
			77:  {expr: "abs(-1)", want: int64(1)},
			78:  {expr: "abs(-1.0)", want: 1.0},
			79:  {expr: "abs(1+1i)", want: cmplx.Abs(1 + 1i)},
			80:  {expr: "abs(-9223372036854775808)", want: 9223372036854775808.0},
			81:  {expr: "abs(inf)", want: math.Inf(1)},
			82:  {expr: "abs(-inf)", want: math.Inf(1)},
			83:  {expr: "abs(nan)", want: math.NaN()},
			84:  {expr: "abs", retErr: true},
			85:  {expr: "abs()", retErr: true},
			86:  {expr: "abs(1,2)", retErr: true},
			87:  {expr: "sqrt(2)", want: math.Sqrt(2)},
			88:  {expr: "sqrt(2.0)", want: math.Sqrt(2)},
			89:  {expr: "sqrt(1+1i)", want: cmplx.Sqrt(1 + 1i)},
			90:  {expr: "sqrt(inf)", want: math.Inf(1)},
			91:  {expr: "sqrt(-inf)", want: math.NaN()},
			92:  {expr: "sqrt(nan)", want: math.NaN()},
			93:  {expr: "sqrt", retErr: true},
			94:  {expr: "sqrt()", retErr: true},
			95:  {expr: "sqrt(1,2)", retErr: true},
			96:  {expr: "pow(2,3)", want: int64(8)},
			97:  {expr: "pow(2.0,3.0)", want: math.Pow(2, 3)},
			98:  {expr: "pow(2i,3i)", want: cmplx.Pow(2i, 3i)},
			99:  {expr: "pow(9223372036854775807,2)", want: math.Pow(math.MaxInt64, 2)},
			100: {expr: "pow(2,0)", want: int64(1)},
			101: {expr: "pow(1,3)", want: int64(1)},
			102: {expr: "pow(2,1)", want: int64(2)},
			103: {expr: "pow(0, -1)", want: math.Inf(1)},
			104: {expr: "pow(0,inf)", want: 0.0},
			105: {expr: "pow(0,-inf)", want: math.Inf(1)},
			106: {expr: "pow(0,-2)", want: math.Inf(1)},
			107: {expr: "pow(-1,inf)", want: 1.0},
			108: {expr: "pow(-1,-inf)", want: 1.0},
			109: {expr: "pow(2,inf)", want: math.Inf(1)},
			110: {expr: "pow(2,-inf)", want: 0.0},
			111: {expr: "pow(0.1,inf)", want: 0.0},
			112: {expr: "pow(0.1,-inf)", want: math.Inf(1)},
			113: {expr: "pow(inf,2)", want: math.Inf(1)},
			114: {expr: "pow(inf,-2)", want: 0.0},
			115: {expr: "pow(-inf,2)", want: math.Inf(1)},
			116: {expr: "pow(-inf,1)", want: math.Inf(-1)},
			117: {expr: "pow(-inf,-1)", want: 0.0},
			118: {expr: "pow(-1, 0.1)", want: math.NaN()},
			119: {expr: "pow", retErr: true},
			120: {expr: "pow(1)", retErr: true},
			121: {expr: "pow(1,2,3)", retErr: true},
			122: {expr: "exp(2)", want: math.Exp(2)},
			123: {expr: "exp(2.0)", want: math.Exp(2)},
			124: {expr: "exp(1i)", want: cmplx.Exp(1i)},
			125: {expr: "exp(inf)", want: math.Inf(1)},
			126: {expr: "exp(-inf)", want: 0.0},
			127: {expr: "exp(nan)", want: math.NaN()},
			128: {expr: "exp", retErr: true},
			129: {expr: "exp()", retErr: true},
			130: {expr: "exp(1,2)", retErr: true},
			131: {expr: "log(2)", want: math.Log(2)},
			132: {expr: "log(2.0)", want: math.Log(2)},
			133: {expr: "log(1i)", want: cmplx.Log(1i)},
			134: {expr: "log(inf)", want: math.Inf(1)},
			135: {expr: "log(0)", want: math.Inf(-1)},
			136: {expr: "log(-1)", want: math.NaN()},
			137: {expr: "log(-inf)", want: math.NaN()},
			138: {expr: "log(nan)", want: math.NaN()},
			139: {expr: "log", retErr: true},
			140: {expr: "log()", retErr: true},
			141: {expr: "log(1,2)", retErr: true},
			142: {expr: "log10(2)", want: math.Log10(2)},
			143: {expr: "log10(2.0)", want: math.Log10(2)},
			144: {expr: "log10(1i)", want: cmplx.Log10(1i)},
			145: {expr: "log10", retErr: true},
			146: {expr: "log10()", retErr: true},
			147: {expr: "log10(1,2)", retErr: true},
			148: {expr: "sin(2)", want: math.Sin(2)},
			149: {expr: "sin(2.0)", want: math.Sin(2)},
			150: {expr: "sin(1i)", want: cmplx.Sin(1i)},
			151: {expr: "sin(inf)", want: math.NaN()},
			152: {expr: "sin(-inf)", want: math.NaN()},
			153: {expr: "sin(nan)", want: math.NaN()},
			154: {expr: "sin", retErr: true},
			155: {expr: "sin()", retErr: true},
			156: {expr: "sin(1,2)", retErr: true},
			157: {expr: "cos(2)", want: math.Cos(2)},
			158: {expr: "cos(2.0)", want: math.Cos(2)},
			159: {expr: "cos(1i)", want: cmplx.Cos(1i)},
			160: {expr: "cos(inf)", want: math.NaN()},
			161: {expr: "cos(-inf)", want: math.NaN()},
			162: {expr: "cos(nan)", want: math.NaN()},
			163: {expr: "cos", retErr: true},
			164: {expr: "cos()", retErr: true},
			165: {expr: "cos(1,2)", retErr: true},
			166: {expr: "tan(2)", want: math.Tan(2)},
			167: {expr: "tan(2.0)", want: math.Tan(2)},
			168: {expr: "tan(1i)", want: cmplx.Tan(1i)},
			169: {expr: "tan(inf)", want: math.NaN()},
			170: {expr: "tan(-inf)", want: math.NaN()},
			171: {expr: "tan(nan)", want: math.NaN()},
			172: {expr: "tan", retErr: true},
			173: {expr: "tan()", retErr: true},
			174: {expr: "tan(1,2)", retErr: true},
			175: {expr: "asin(0)", want: math.Asin(0)},
			176: {expr: "asin(0.0)", want: math.Asin(0)},
			177: {expr: "asin(1i)", want: cmplx.Asin(1i)},
			178: {expr: "asin(2)", want: math.NaN()},
			179: {expr: "asin(-2)", want: math.NaN()},
			180: {expr: "asin(inf)", want: math.NaN()},
			181: {expr: "asin(-inf)", want: math.NaN()},
			182: {expr: "asin(nan)", want: math.NaN()},
			183: {expr: "asin", retErr: true},
			184: {expr: "asin()", retErr: true},
			185: {expr: "asin(1,2)", retErr: true},
			186: {expr: "acos(0)", want: math.Acos(0)},
			187: {expr: "acos(0.0)", want: math.Acos(0)},
			188: {expr: "acos(1i)", want: cmplx.Acos(1i)},
			189: {expr: "acos(2)", want: math.NaN()},
			190: {expr: "acos(-2)", want: math.NaN()},
			191: {expr: "acos(inf)", want: math.NaN()},
			192: {expr: "acos(-inf)", want: math.NaN()},
			193: {expr: "acos(nan)", want: math.NaN()},
			194: {expr: "acos", retErr: true},
			195: {expr: "acos()", retErr: true},
			196: {expr: "acos(1,2)", retErr: true},
			197: {expr: "atan(0)", want: math.Atan(0)},
			198: {expr: "atan(0.0)", want: math.Atan(0)},
			199: {expr: "atan(1i)", want: cmplx.Atan(1i)},
			200: {expr: "atan(inf)", want: math.Pi / 2},
			201: {expr: "atan(-inf)", want: -math.Pi / 2},
			202: {expr: "atan(nan)", want: math.NaN()},
			203: {expr: "atan", retErr: true},
			204: {expr: "atan()", retErr: true},
			205: {expr: "atan(1,2)", retErr: true},
			206: {expr: "sinh(0)", want: math.Sinh(0)},
			207: {expr: "sinh(0.0)", want: math.Sinh(0)},
			208: {expr: "sinh(1i)", want: cmplx.Sinh(1i)},
			209: {expr: "sinh(inf)", want: math.Inf(1)},
			210: {expr: "sinh(-inf)", want: math.Inf(-1)},
			211: {expr: "sinh(nan)", want: math.NaN()},
			212: {expr: "sinh", retErr: true},
			213: {expr: "sinh()", retErr: true},
			214: {expr: "sinh(1,2)", retErr: true},
			215: {expr: "cosh(0)", want: math.Cosh(0)},
			216: {expr: "cosh(0.0)", want: math.Cosh(0)},
			217: {expr: "cosh(1i)", want: cmplx.Cosh(1i)},
			218: {expr: "cosh(inf)", want: math.Inf(1)},
			219: {expr: "cosh(-inf)", want: math.Inf(1)},
			220: {expr: "cosh(nan)", want: math.NaN()},
			221: {expr: "cosh", retErr: true},
			222: {expr: "cosh()", retErr: true},
			223: {expr: "cosh(1,2)", retErr: true},
			224: {expr: "tanh(0)", want: math.Tanh(0)},
			225: {expr: "tanh(0.0)", want: math.Tanh(0)},
			226: {expr: "tanh(1i)", want: cmplx.Tanh(1i)},
			227: {expr: "tanh(inf)", want: 1.0},
			228: {expr: "tanh(-inf)", want: -1.0},
			229: {expr: "tanh(nan)", want: math.NaN()},
			230: {expr: "tanh", retErr: true},
			231: {expr: "tanh()", retErr: true},
			232: {expr: "tanh(1,2)", retErr: true},
			233: {expr: "asinh(0)", want: math.Asinh(0)},
			234: {expr: "asinh(0.0)", want: math.Asinh(0)},
			235: {expr: "asinh(1i)", want: cmplx.Asinh(1i)},
			236: {expr: "asinh(inf)", want: math.Inf(1)},
			237: {expr: "asinh(-inf)", want: math.Inf(-1)},
			238: {expr: "asinh(nan)", want: math.NaN()},
			239: {expr: "asinh", retErr: true},
			240: {expr: "asinh()", retErr: true},
			241: {expr: "asinh(1,2)", retErr: true},
			242: {expr: "acosh(1)", want: math.Acosh(1)},
			243: {expr: "acosh(1.0)", want: math.Acosh(1)},
			244: {expr: "acosh(1i)", want: cmplx.Acosh(1i)},
			245: {expr: "acosh(inf)", want: math.Inf(1)},
			246: {expr: "acosh(-inf)", want: math.NaN()},
			247: {expr: "acosh(0)", want: math.NaN()},
			248: {expr: "acosh(nan)", want: math.NaN()},
			249: {expr: "acosh", retErr: true},
			250: {expr: "acosh()", retErr: true},
			251: {expr: "acosh(1,2)", retErr: true},
			252: {expr: "atanh(0)", want: math.Atanh(0)},
			253: {expr: "atanh(0.0)", want: math.Atanh(0)},
			254: {expr: "atanh(1i)", want: cmplx.Atanh(1i)},
			255: {expr: "atanh(1)", want: math.Inf(1)},
			256: {expr: "atanh(-1)", want: math.Inf(-1)},
			257: {expr: "atanh(2)", want: math.NaN()},
			258: {expr: "atanh(-2)", want: math.NaN()},
			259: {expr: "atanh(inf)", want: math.NaN()},
			260: {expr: "atanh(-inf)", want: math.NaN()},
			261: {expr: "atanh(nan)", want: math.NaN()},
			{expr: "fn(0)", retErr: true},
			{expr: "fn(0)", funcs: map[string]ExprFunc{"fn": fn}, want: 0.0},
			{expr: "fn()", funcs: map[string]ExprFunc{"fn": fn}, retErr: true},
		}

		for i, test := range tests {
			testParse(t, i, test)
		}
	})
}
